Title: 性能优化核心范式
Date: 2025-04-19
Category: 性能优化

> **一次性能优化的成功，像打 Boss：先明确血条，再锁定弱点，最后用最高 DPS 的武器；缺一环都会团灭。**  
> 下面把整条打法浓缩成 **2 条哲学 + 3 个模型 + 4 步闭环 + 5 层手术刀 + 6 个常见误区**，拿走就能直接套用。

---

## 1. 两条底层哲学

| 哲学 | 释义 | 行为准则 |
|------|------|-----------|
| **目标驱动** | “快一点”≠优化；必须把场景 ➜ 指标 ➜ 阈值写成数字 | **先写 OKR**：30 FPS → 60 FPS；内存 ≤ 512 MB |
| **数据至上** | 见不到火焰图就别动代码，凭感觉改=玩 Russian Roulette | **先量化再动手**：采样→Trace→排序 Top‑N |

---

## 2. 三个关键模型

| 模型 | 核心问题 | 立刻能做什么 |
|------|----------|-------------|
| **Amdahl** | 串行段决定上限 | 把“不能并行的 5 %”列白名单 |
| **Roofline** | 算力 vs 带宽 | 计算密集？就算；带宽受限？就重排数据 |
| **Little** | 并发=吞吐×延迟 | 调「队列深度」就能消拥塞 |

---

## 3. 四步闭环（Perf CI 推荐流程）

1. **Measure**：一键脚本跑基准，输出 JSON  
2. **Diagnose**：火焰图 / Chrome Trace 自动归并 Top‑N  
3. **Fix**：挑 ROI 最高的一个动刀  
4. **Verify & Guardrail**：变动 ≤ –20 % 性能才允许 Merge；否则打回

> **Tips**：把脚本绑在 PR 的 GitHub Action 里，红灯=阈值超标。

---

## 4. 五层手术刀（收益/代价递减顺序）

| 层级 | 代表手段 | 派上用场的典型场景 |
|------|----------|--------------------|
| 1️⃣ 算法/逻辑 | O(n²)→O(n log n)、剪枝、近似 | AI 寻路、图形剔除 |
| 2️⃣ 数据布局 | SoA / 内存池 / Cache Line 对齐 | 物理、渲染批处理 |
| 3️⃣ 并行模型 | SIMD / GPU kernel / 任务图 | 粒子系统、音频解码 |
| 4️⃣ 系统架构 | Producer‑Consumer、资源池化 | 热更新、Chunk Streaming |
| 5️⃣ 硬件特性 | NUMA 亲和、Tile‑Based、Zero‑Copy | 移动端、主机独占功能 |

---

## 5. 快速索引表（遇事先翻这里）

| 想省下 | 优先选项 | 口诀 |
|--------|---------|------|
| **CPU ms** | 批量 → 并行 → 表驱动 | “循环外移 + 批量干掉调用栈” |
| **GPU ms** | 合批 → 剔除 → Early‑Z | “让 GPU 少等、少画” |
| **内存** | 共享 + 压缩 + 懒加载 | “占不完？就晚点分配” |
| **带宽** | Chunk + 重用 + 压缩 | “一字节最好用两次” |
| **功耗** | 动态分辨率、帧率削峰 | “电池先活下来” |

---

## 6. 六大常见误区（踩坑黑名单）

1. **没指标就开干** → 结果不可证伪  
2. **把火焰图碎片都抹平** → 80 % 代码白优化  
3. **平均提速 5 % 就宣告胜利** → 串行段未动摇  
4. **局部最快却整体变慢** → 破坏并行度  
5. **Release 与 Debug 数据混用** → 误判热点  
6. **改完不加监控** → 回归 Bug 无从追溯  

---

## 7. 代码/脚本快速上手示例

```bash
# perf_ci.sh —— 示例：Linux 服务端帧耗基准
SCENE=${1:-"login"}
OUT="perf_${SCENE}_$(date +%s).json"

# 1. Measure
./run_game --scene=$SCENE --record=trace.json
python tools/trace2json.py trace.json > $OUT

# 2. Diagnose & Fail‑Fast
SLOW=$(jq '.events[] | select(.dur>3000)' $OUT | wc -l)
if [ $SLOW -gt 0 ]; then
  echo "❌ Performance regression detected"
  exit 1
fi
echo "✅ Pass: no slow events over 3 ms"
```

把它接进 GitHub Actions，每次 PR 自动跑；阈值可配成 FPS、内存、GC 次数等多维度。

---

### 结语

> **优化不是“写更快的代码”，而是“用更少的复杂度买到可验证的业务价值，并把这个过程商品化”。**  
> 掌握上面这套 **“目标→度量→定位→设计→验证→守护”** 的闭环，才能让性能变成可管理资产，而不是靠“天赋与吭哧”堆起来的偶然奇迹。祝下次打开火焰图，你一眼看见的全是机会，而不是噩梦。