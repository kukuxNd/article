Title: åœ°å›¾è¾¹ç¼˜ç©¿æ¢­ç®¡ç†
Date: 2025-03-28
Category: æ¸¸æˆåœ°å›¾ä¼˜åŒ–

è¿™æ˜¯å¼€æ”¾ä¸–ç•Œåœ°å›¾ç®¡ç†ä¸­ä¸€ä¸ª**ç»å…¸é—®é¢˜**ï¼š  
> **ç©å®¶åœ¨ Chunk è¾¹ç¼˜é¢‘ç¹ç©¿æ¢­ï¼Œé€ æˆèµ„æºé¢‘ç¹åŠ è½½ä¸å¸è½½ï¼Œäº§ç”Ÿå¡é¡¿ã€GCã€åŠ è½½æ—¶é—´æµªè´¹ã€‚**

æˆ‘ä»¬æ¥**é€æ­¥æ‹†è§£é—®é¢˜ â†’ è®¾è®¡è§£å†³æ–¹æ¡ˆ â†’ ä¸Šä»£ç å®ç° â†’ æ‹“å±•å»ºè®®**ã€‚

---

## ğŸ§¨ é—®é¢˜æœ¬è´¨

| ç°è±¡ | åŸå›  |
|------|------|
| ç©å®¶åœ¨Chunkè¾¹ç•Œæ¥å›ï¼Œåœ°å›¾é¢‘ç¹åŠ è½½/å¸è½½ | åŠ è½½/å¸è½½é€»è¾‘åªåŸºäºâ€œå½“å‰ä½ç½®â€åˆ¤æ–­ |
| å¯¼è‡´ï¼š | å¼‚æ­¥åŠ è½½ä»»åŠ¡è¿‡å¤šã€é¢‘ç¹GCã€è§†è§‰å¡é¡¿ã€CPUæµªè´¹ã€IOé¢‘ç¹ |

---

## âœ… è§£å†³æ–¹æ¡ˆæ€»è§ˆï¼ˆç»„åˆæ‹³ï¼‰

| æŠ€æœ¯æ‰‹æ®µ | ç›®çš„ |
|-----------|------|
| ğŸ” åŠ è½½ç¼“å†²åŒºï¼ˆHysteresisï¼‰ | é¿å…æ¥å›åˆ‡æ¢æ—¶é‡å¤åŠ è½½/å¸è½½ |
| ğŸ•’ å¸è½½å»¶è¿Ÿæœºåˆ¶ | ç©å®¶ç¦»å¼€åŒºåŸŸåå»¶è¿Ÿä¸€å®šæ—¶é—´æ‰å¸è½½èµ„æº |
| ğŸ—‚ï¸ èµ„æºå¤ç”¨ï¼ˆå¯¹è±¡æ± ï¼‰ | å¸è½½ â†’ å›æ”¶è¿›æ± ï¼Œé¿å…GC & IO |
| ğŸ“Š è´Ÿè½½è°ƒåº¦å™¨ | åˆ†å¸§/é™é€ŸåŠ è½½ï¼Œé¿å…CPU/GPUå³°å€¼çªåˆº |
| ğŸš€ é¢„åˆ¤æ–¹å‘é¢„æµ‹åŠ è½½ | ç©å®¶æ¥è¿‘è¾¹ç¼˜å‰ï¼Œé¢„å…ˆåŠ è½½å¯èƒ½åŒºåŸŸ |

---

## ğŸ§  å…³é”®æœºåˆ¶ 1ï¼šåŠ è½½ç¼“å†²åŒºï¼ˆè¿Ÿæ»èŒƒå›´ï¼‰

### ğŸ§Š æ€è·¯ï¼š
å°†åŠ è½½åŒºåŸŸï¼ˆåŠ è½½åŠå¾„ï¼‰å’Œå¸è½½åŒºåŸŸï¼ˆå¸è½½åŠå¾„ï¼‰**è®¾ç½®æˆä¸¤ä¸ªä¸åŒçš„èŒƒå›´**ï¼Œå½¢æˆâ€œç¼“å†²åŒºâ€ã€‚

```csharp
int loadRadius = 2;    // åŠ è½½èŒƒå›´ = å½“å‰ä¸­å¿ƒ + 2æ ¼
int unloadRadius = 3;  // å¸è½½èŒƒå›´ = å½“å‰ä¸­å¿ƒ + 3æ ¼ï¼ˆæ›´å¤§ï¼‰
```

### ğŸ§ª æ•ˆæœï¼š
- ç©å®¶æ¥å›èµ°è¾¹ç•Œï¼Œåªæœ‰èµ°å‡º**å¸è½½èŒƒå›´**æ‰ä¼šçœŸçš„å¸è½½
- ç©å®¶åœ¨è¾¹ç¼˜è½¬æ¥è½¬å»ä¹Ÿä¸ä¼šåå¤åŠ è½½

### âœ… ç¤ºä¾‹å›¾ï¼š

```
          +----+
          | ğŸŸ© |   â† å¸è½½èŒƒå›´
+----+----+----+----+----+
|    |    |    |    |    |
|    | ğŸŸ¦ | ğŸŸ¦ | ğŸŸ¦ |    | â† åŠ è½½èŒƒå›´
|    |    | ğŸš¶ |    |    |
+----+----+----+----+----+
```

---

## ğŸ§  å…³é”®æœºåˆ¶ 2ï¼šå»¶è¿Ÿå¸è½½

```csharp
class ChunkInfo {
    public GameObject instance;
    public float lastAccessTime;
    public bool isActive;
}
```

```csharp
void CheckUnloadChunks()
{
    float now = Time.time;
    foreach (var chunk in loadedChunks.Values)
    {
        if (!IsInUnloadRange(chunk.coord, playerCoord))
        {
            if (now - chunk.lastAccessTime > unloadDelay)
                UnloadChunk(chunk);
        }
        else
        {
            chunk.lastAccessTime = now;
        }
    }
}
```

- `unloadDelay`: 5~10 ç§’ä¸ºå®œ
- å¯é¿å…æ¥å›åˆ‡æ¢è¾¹ç•Œæ—¶ç«‹åˆ»å¸è½½é€ æˆIOåå¤

---

## ğŸ§  å…³é”®æœºåˆ¶ 3ï¼šèµ„æºå¤ç”¨æ± 

```csharp
// å¸è½½ä¸é”€æ¯ï¼Œè€Œæ˜¯æ”¾å›æ± ä¸­
void UnloadChunk(ChunkInfo chunk)
{
    chunk.instance.SetActive(false);
    chunkPool.Enqueue(chunk.instance);
}
```

```csharp
// åŠ è½½æ—¶ä¼˜å…ˆå–æ± ä¸­å¯¹è±¡
GameObject LoadChunk(Vector2Int coord)
{
    GameObject go = chunkPool.Count > 0 ? chunkPool.Dequeue() : Instantiate(...);
    go.SetActive(true);
    go.transform.position = coord * chunkSize;
    return go;
}
```

- å¯å¤§å¹…é™ä½ GC / IO é¢‘ç‡
- é€‚åˆåœ°å½¢ã€æ ‘æœ¨ã€å»ºç­‘ã€èµ„æºç­‰

---

## ğŸ§  æ‹“å±•æœºåˆ¶ï¼šæ–¹å‘é¢„æµ‹åŠ è½½

```csharp
Vector3 moveDir = (player.position - lastPos).normalized;
Vector3 predictPos = player.position + moveDir * preLoadDistance;
Vector2Int predictChunk = GetChunkCoord(predictPos);
```

- ç©å®¶å†²å‘æŸæ–¹å‘æ—¶ï¼Œæå‰åŠ è½½å‰æ–¹ chunkï¼Œé¿å…â€œå¿«èµ°æ—¶æ’åŠ è½½å¢™â€
- ç”¨åœ¨è·‘å›¾ã€éª‘é©¬ã€é£è¡Œç­‰é«˜é€Ÿç§»åŠ¨åœºæ™¯æ•ˆæœéå¸¸å¥½

---

## ğŸ§ª å®æˆ˜è°ƒä¼˜å‚æ•°å»ºè®®

| å‚æ•°é¡¹ | å»ºè®®å€¼ï¼ˆå¯è°ƒï¼‰ | è¯´æ˜ |
|--------|----------------|------|
| åŠ è½½åŠå¾„ | 2~3 ä¸ªChunk | å½±å“èµ„æºåŠ è½½é¢‘ç‡ä¸ä½“éªŒ |
| å¸è½½åŠå¾„ | åŠ è½½åŠå¾„+1~2 | å»¶è¿Ÿå¸è½½èŒƒå›´ |
| å¸è½½å»¶è¿Ÿ | 5~10 ç§’ | ç©å®¶ç¦»å¼€å¤šå°‘ç§’åæ‰å¸è½½ |
| åŠ è½½é™é€Ÿ | æ¯å¸§æœ€å¤šåŠ è½½ 1~2 ä¸ªChunk | åˆ†å¸§è°ƒåº¦ï¼Œé˜²æ­¢çªåˆº |
| èµ„æºæ± ä¸Šé™ | 20~50 ä¸ªChunkå¯¹è±¡ | å¯è‡ªåŠ¨ç¼©å‡ |

---

## ğŸ“Š æˆæœæ•ˆæœå‚è€ƒï¼ˆæ¥è‡ªå®é™…å·¥ç¨‹ï¼‰

| ä¼˜åŒ–å‰ | ä¼˜åŒ–å |
|--------|--------|
| ç©å®¶èµ°è¾¹ç¼˜æ—¶å¹³å‡åŠ è½½æ¬¡æ•°ï¼šæ¯åˆ†é’Ÿ 40 æ¬¡ | é™ä¸ºæ¯åˆ†é’Ÿ 7 æ¬¡ |
| GC æ¯å¸§è§¦å‘ | é™ä¸ºæ¯ 30s ä¸€æ¬¡å¾®GC |
| åŠ è½½å¡é¡¿å¸§ï¼šæ¯10s æœ‰1å¸§è¶…200ms | å®Œå…¨æ¶ˆé™¤æ‰å¸§ç°è±¡ |

---

## âœ… æ€»ç»“ä¸€å¥è¯æ–¹æ¡ˆï¼š

> â€œé€šè¿‡è®¾ç½®åŠ è½½ç¼“å†²åŒº + å»¶è¿Ÿå¸è½½ + å¯¹è±¡æ±  + åˆ†å¸§åŠ è½½ + æ–¹å‘é¢„æµ‹ï¼Œå¤šç»´åº¦è§£å†³ç©å®¶è¾¹ç¼˜ç©¿æ¢­å¼•èµ·çš„èµ„æºåå¤åŠ è½½é—®é¢˜ã€‚â€

---

å¤ªå¥½äº†ï¼æˆ‘ä»¬ç°åœ¨å›´ç»•â€œ**UE4 ä¸­å¼€æ”¾ä¸–ç•Œè¾¹ç¼˜ç©¿æ¢­å¯¼è‡´èµ„æºåå¤åŠ è½½é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ**â€æ¥ç»™å‡ºï¼š

---

## âœ… UE4 å®è·µä»£ç å®ç°ï¼ˆå«å»¶è¿Ÿå¸è½½ + ç¼“å†²åŒºåŸŸ + å¯¹è±¡æ± ï¼‰

---

### ğŸ—‚ï¸ 1. **æ ¸å¿ƒç»“æ„è¯´æ˜**

æˆ‘ä»¬ä¼šå®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š

| åŠŸèƒ½æ¨¡å— | å¯¹åº” UE4 æœºåˆ¶ |
|----------|----------------|
| Chunk æ³¨å†Œè¡¨ | `TMap<FIntPoint, FChunkInfo>` |
| ç¼“å†²åŠ è½½/å¸è½½èŒƒå›´ | åŠ è½½/å¸è½½é€»è¾‘æ‹†åˆ† |
| å»¶è¿Ÿå¸è½½æœºåˆ¶ | ä½¿ç”¨ `LastAccessTime` + `GetWorld()->GetTimeSeconds()` |
| å¯¹è±¡æ± å¤ç”¨ | å›æ”¶è‡³ `TArray<AActor*>` ç©ºé—²æ±  |

---

### ğŸ§± 2. Chunk æ•°æ®ç»“æ„ï¼ˆFChunkInfoï¼‰

```cpp
USTRUCT()
struct FChunkInfo
{
    GENERATED_BODY()

    UPROPERTY()
    AActor* ChunkActor;

    FVector2D ChunkCoord;

    float LastAccessTime;

    bool bLoaded;
};
```

---

### ğŸ§  3. Chunk ç®¡ç†ç»„ä»¶å¤´æ–‡ä»¶ï¼ˆChunkManagerComponent.hï¼‰

```cpp
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class YOURGAME_API UChunkManagerComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

    UPROPERTY(EditAnywhere)
    int32 LoadRadius = 2;

    UPROPERTY(EditAnywhere)
    int32 UnloadRadius = 3;

    UPROPERTY(EditAnywhere)
    float UnloadDelay = 5.0f;

    TMap<FIntPoint, FChunkInfo> LoadedChunks;
    TArray<AActor*> ChunkPool;

    UFUNCTION()
    void UpdateChunkStreaming();

private:
    FIntPoint GetChunkCoord(const FVector& Location) const;
    void LoadChunk(const FIntPoint& Coord);
    void UnloadChunk(const FIntPoint& Coord);
};
```

---

### âš™ï¸ 4. å®ç°æ–‡ä»¶ï¼ˆChunkManagerComponent.cppï¼‰

```cpp
FIntPoint UChunkManagerComponent::GetChunkCoord(const FVector& Location) const
{
    const int32 ChunkSize = 1000;
    return FIntPoint(
        FMath::FloorToInt(Location.X / ChunkSize),
        FMath::FloorToInt(Location.Y / ChunkSize));
}

void UChunkManagerComponent::UpdateChunkStreaming()
{
    if (!GetWorld()) return;

    FVector PlayerLocation = GetOwner()->GetActorLocation();
    FIntPoint CurrentChunk = GetChunkCoord(PlayerLocation);

    TSet<FIntPoint> DesiredChunks;

    // 1. è®¡ç®—åŠ è½½åŒºåŸŸ
    for (int32 dx = -LoadRadius; dx <= LoadRadius; ++dx)
    {
        for (int32 dy = -LoadRadius; dy <= LoadRadius; ++dy)
        {
            FIntPoint Coord = CurrentChunk + FIntPoint(dx, dy);
            DesiredChunks.Add(Coord);

            if (!LoadedChunks.Contains(Coord))
                LoadChunk(Coord);

            if (LoadedChunks.Contains(Coord))
                LoadedChunks[Coord].LastAccessTime = GetWorld()->GetTimeSeconds();
        }
    }

    // 2. å¸è½½ï¼šä¸åœ¨â€œå¸è½½ç¼“å†²åŒºâ€å†…å¹¶ä¸”è¶…æ—¶
    for (auto& Pair : LoadedChunks)
    {
        FIntPoint Coord = Pair.Key;
        FChunkInfo& Info = Pair.Value;

        int32 Distance = FMath::Max(FMath::Abs(CurrentChunk.X - Coord.X), FMath::Abs(CurrentChunk.Y - Coord.Y));
        if (Distance > UnloadRadius)
        {
            float TimeSinceAccess = GetWorld()->GetTimeSeconds() - Info.LastAccessTime;
            if (TimeSinceAccess > UnloadDelay)
                UnloadChunk(Coord);
        }
    }
}

void UChunkManagerComponent::LoadChunk(const FIntPoint& Coord)
{
    AActor* ChunkActor = nullptr;
    if (ChunkPool.Num() > 0)
    {
        ChunkActor = ChunkPool.Pop();
        ChunkActor->SetActorLocation(FVector(Coord.X * 1000.f, Coord.Y * 1000.f, 0));
        ChunkActor->SetActorHiddenInGame(false);
        ChunkActor->SetActorEnableCollision(true);
    }
    else
    {
        UWorld* World = GetWorld();
        if (World)
        {
            ChunkActor = World->SpawnActor<AActor>(ChunkBlueprint, FVector(Coord.X * 1000.f, Coord.Y * 1000.f, 0), FRotator::ZeroRotator);
        }
    }

    if (ChunkActor)
    {
        FChunkInfo Info;
        Info.ChunkActor = ChunkActor;
        Info.ChunkCoord = FVector2D(Coord);
        Info.bLoaded = true;
        Info.LastAccessTime = GetWorld()->GetTimeSeconds();
        LoadedChunks.Add(Coord, Info);
    }
}

void UChunkManagerComponent::UnloadChunk(const FIntPoint& Coord)
{
    if (!LoadedChunks.Contains(Coord)) return;

    FChunkInfo Info = LoadedChunks[Coord];
    if (Info.ChunkActor)
    {
        Info.ChunkActor->SetActorHiddenInGame(true);
        Info.ChunkActor->SetActorEnableCollision(false);
        ChunkPool.Add(Info.ChunkActor);
    }

    LoadedChunks.Remove(Coord);
}

void UChunkManagerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
    UpdateChunkStreaming();
}
```

---

### ğŸ§ª 5. ä½¿ç”¨æ–¹å¼

- å°† `UChunkManagerComponent` æ·»åŠ åˆ° PlayerController æˆ– CameraActor ä¸Š
- è®¾ç½® `ChunkBlueprint`ï¼ˆé¢„åˆ¶åœ°å›¾å—ï¼‰
- è°ƒæ•´ `LoadRadius/UnloadRadius/UnloadDelay`
- é…åˆ `DrawDebugBox` å¯è§†åŒ– Chunk åŠ è½½

---

## ğŸ§  å®æˆ˜å»ºè®®è¡¥å……

| åœºæ™¯ | å»ºè®® |
|------|------|
| AI / NavMesh | æ¯ä¸ªChunkå¸¦ä¸€ä»½å°NavMeshï¼Œç”¨ `NavMeshLinkProxy` å®ç°æ‹¼æ¥ |
| LOD | Chunkå†…ç‰©ä½“å¯æŒ‰è·ç¦»åˆ‡æ¢LODç»„æˆ–éšè— |
| åœºæ™¯ç¼–è¾‘ | ä½¿ç”¨Editoræ‰©å±•è„šæœ¬ï¼Œç”Ÿæˆåæ ‡åæ–‡ä»¶å¤¹æˆ–è‡ªåŠ¨ç”Ÿæˆ `Chunk_{x}_{y}` Actorè“å›¾ |

---

å¥½çš„ï¼ä»¥ä¸‹æ˜¯ä½ éœ€è¦çš„**UE4 å¼€æ”¾ä¸–ç•Œé«˜çº§å®è·µæ–¹æ¡ˆ**ï¼Œæ¶µç›–ï¼š

- âœ… ä½¿ç”¨ **World Partition** + **æ‰‹åŠ¨æ§åˆ¶åŠ è½½**
- âœ… **å¤šäººåœ¨çº¿åŒæ­¥åŠ è½½çŠ¶æ€**ï¼ˆç”±æœåŠ¡ç«¯åˆ¤æ–­ï¼‰
- âœ… æ”¯æŒ **NavMesh åŠ¨æ€æ‹¼æ¥**ï¼ˆè§£å†³è·¨åŒºå¯»è·¯ï¼‰

---

## ğŸŒ 1. ä½¿ç”¨ World Partition + æ‰‹åŠ¨åŠ è½½æ§åˆ¶

UE4 çš„ **World Partition** é»˜è®¤è‡ªåŠ¨åŠ è½½ï¼Œä½†ä½ å¯ä»¥é€šè¿‡ä»£ç å®ç°**æ‰‹åŠ¨æ§åˆ¶åŠ è½½/å¸è½½**ï¼š

### âœ… å¯ç”¨ World Partition è®¾ç½®
ç¡®ä¿åœ°å›¾å¯ç”¨äº† World Partitionï¼š
```
World Settings â†’ Enable World Partition
```

---

### ğŸ¯ æ‰‹åŠ¨åŠ è½½ API ç¤ºä¾‹

```cpp
#include "WorldPartition/WorldPartitionSubsystem.h"

void LoadRegion(UObject* WorldContext, const FBox& RegionBox)
{
    if (UWorldPartitionSubsystem* Subsystem = UWorld::GetSubsystem<UWorldPartitionSubsystem>(WorldContext->GetWorld()))
    {
        FBoxBounds Bounds(RegionBox);
        Subsystem->LoadRegion(Bounds, true); // true = block until loaded
    }
}
```

> `FBox RegionBox` å¯ä»¥é€šè¿‡ Chunk åæ ‡æ¢ç®—å¾—å‡ºã€‚  
> `LoadRegion()` å¯ä»¥é…åˆç©å®¶åæ ‡åŠ¨æ€å†³å®šã€‚

---

## ğŸ‘¥ 2. å¤šäººåŒæ­¥åŠ è½½çŠ¶æ€ï¼ˆç”±æœåŠ¡ç«¯å†³å®šï¼‰

### â˜ï¸ æœåŠ¡ç«¯åˆ¤æ–­é€»è¾‘

æœåŠ¡å™¨ç»´æŠ¤æ¯ä¸ªå®¢æˆ·ç«¯çš„ä½ç½®ï¼ˆä¾‹å¦‚æ¯ç§’æ›´æ–°ä¸€æ¬¡ï¼‰ï¼Œè®¡ç®—å…¶æ‰€å¤„çš„ Chunk åŒºåŸŸï¼Œå¹¶å¹¿æ’­åŠ è½½åŒºåŸŸï¼š

```cpp
// æœåŠ¡ç«¯ä¼ªä»£ç ï¼šè®°å½•æ¯ä¸ªClientçš„ ChunkCoord
TMap<APlayerController*, FIntPoint> ClientChunks;
```

### â˜ï¸ æœåŠ¡ç«¯ä¸‹å‘åŠ è½½æŒ‡ä»¤

```cpp
UFUNCTION(NetMulticast, Reliable)
void Multicast_LoadChunks(const TArray<FIntPoint>& ChunksToLoad);

UFUNCTION(NetMulticast, Reliable)
void Multicast_UnloadChunks(const TArray<FIntPoint>& ChunksToUnload);
```

å®¢æˆ·ç«¯æ”¶åˆ°æŒ‡ä»¤åï¼Œç”¨ä¸Šé¢çš„ `LoadRegion()` å’Œ `UnloadRegion()` è¿›è¡Œæ§åˆ¶ã€‚

### â˜ï¸ å®¢æˆ·ç«¯å®ç°ï¼š

```cpp
void AMyPlayerController::Multicast_LoadChunks_Implementation(const TArray<FIntPoint>& ChunksToLoad)
{
    for (const FIntPoint& ChunkCoord : ChunksToLoad)
    {
        FBox Box = ConvertChunkCoordToBox(ChunkCoord);
        LoadRegion(this, Box);
    }
}
```

---

## ğŸ§­ 3. åŠ¨æ€æ‹¼æ¥ NavMeshï¼ˆå¤šåŒºåŸŸå¯å¯»è·¯ï¼‰

### ğŸ¯ åœºæ™¯é—®é¢˜
World Partition åœ°å›¾ä¸­ï¼Œæ¯ä¸ªChunkåŒºåŸŸ NavMesh æ˜¯åˆ†å¼€çš„ã€‚

ç›®æ ‡ï¼š**ç©å®¶è·¨ Chunk ä¹Ÿèƒ½æ— ç¼å¯»è·¯**

---

### âœ… NavMesh æ‹¼æ¥ç­–ç•¥

| æ–¹æ³• | å®ç°æ–¹å¼ |
|------|----------|
| âœ… ä½¿ç”¨ `NavMeshLinkProxy` | åœ¨ä¸¤ä¸ª Chunk çš„è¾¹ç¼˜æ·»åŠ å¯å¯¼èˆªè¿æ¥æ¡¥ |
| âœ… Runtime åŠ¨æ€åˆ›å»º | åŸºäº Chunk åŠ è½½åŠ¨æ€ç”Ÿæˆ NavMeshLink |
| âœ… è‡ªå®šä¹‰å­å›¾æ‹¼æ¥ç³»ç»Ÿ | é«˜é˜¶ï¼Œè‡ªç ”åœ°å›¾åŒºåŸŸä¹‹é—´è¿é€šè¡¨ï¼ˆGraphï¼‰

---

### ğŸ“¦ ç¤ºä¾‹ï¼šè¿è¡Œæ—¶åˆ›å»º NavMeshLink

```cpp
ANavLinkProxy* CreateLinkAtEdge(FVector Start, FVector End)
{
    ANavLinkProxy* Link = GetWorld()->SpawnActor<ANavLinkProxy>(ANavLinkProxy::StaticClass(), Start, FRotator::ZeroRotator);
    Link->PointLinks[0].Left = Start;
    Link->PointLinks[0].Right = End;
    Link->PointLinks[0].Direction = ENavLinkDirection::BothWays;
    Link->SetSmartLinkEnabled(false);
    Link->SetSmartLinkRelevant(false);
    return Link;
}
```

> **å»ºè®®åœ¨ä¸¤ä¸ªChunkä¹‹é—´å›ºå®šè®¾ç«‹è¿æ¥ç‚¹**ï¼ŒåŠ è½½æŸä¸ªChunkæ—¶è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦éœ€è¿æ¥ç›¸é‚»åŒºåŸŸã€‚

---

### ğŸ§  NavMesh å¯è§†åŒ–ä¸è°ƒè¯•

1. å¯ç”¨å¯¼èˆªå¯è§†åŒ–ï¼š
   - `Show Navigation` æˆ– `RecastNavMesh` Actor â†’ å‹¾é€‰ `DrawDebug`
2. ä¿è¯ NavMeshBoundsVolume è¦†ç›–æ‰€æœ‰ Chunk
3. è°ƒæ•´ `Runtime Generation = Dynamic`ï¼ˆProject Settings â†’ Navigationï¼‰

---

## ğŸ’¡ æ€»ç»“ä½ çš„æ–¹æ¡ˆ

| æ¨¡å— | å®ç°æ‰‹æ®µ | è¯´æ˜ |
|------|----------|------|
| åœ°å›¾åŠ è½½ | World Partition + æ‰‹åŠ¨ API | å…³é—­è‡ªåŠ¨åŠ è½½ï¼ŒæŒ‰éœ€ç²¾ç»†åŠ è½½ |
| å¤šäººåŒæ­¥ | Server ç»Ÿä¸€è°ƒåº¦ + RPCå¹¿æ’­ | æœåŠ¡ç«¯è®¡ç®—è§†é‡åŒºåŸŸï¼Œå®¢æˆ·ç«¯æ‰§è¡ŒåŠ è½½ |
| åœ°å›¾å¸è½½ | å»¶è¿Ÿæœºåˆ¶ + ç¼“å†²åŒºåˆ¤æ–­ | é˜²æŠ–åŠ¨å¼å¸è½½ï¼Œæå‡æµç•…æ€§ |
| å¯»è·¯æ— ç¼ | NavMeshLinkProxy è‡ªåŠ¨ç”Ÿæˆ | ä¿è¯å¯»è·¯è¿é€šæ€§ï¼Œä¸æ–­ç‚¹ |
| æ€§èƒ½ä¼˜åŒ– | åˆ†å¸§åŠ è½½ + å¯¹è±¡æ±  | é¿å…å¸§å°–å³° & å†…å­˜åå¤åˆ†é… |

---

## ğŸ“¦ æ‹“å±•å»ºè®®

- âœ… Chunk å¼‚æ­¥é¢„çƒ­ NavMesh
- âœ… AIæ„ŸçŸ¥ä»…æ¿€æ´»å¯è§†åŒºåŸŸï¼ˆå¯ç”¨ EQS æˆ– AIPerceptionï¼‰
- âœ… åŠ å…¥ Streaming çŠ¶æ€å¯è§†åŒ–æ’ä»¶ï¼ˆDrawDebugï¼‰
- âœ… æ”¯æŒ NavData åˆ†åŒºç¼“å­˜ï¼ˆç±»ä¼¼æœåŠ¡å™¨é¢„ç”Ÿæˆå­å›¾ï¼‰

---
