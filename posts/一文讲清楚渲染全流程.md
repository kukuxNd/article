Title: 一文讲清楚渲染全流程
Date: 2024-05-18
Category: 图形渲染

在现代实时图形引擎中，**一帧画面的生成大致可拆成 CPU 提交 → GPU 流水线处理 → 显示输出三大阶段**；性能瓶颈既可能出在 CPU（指令与资源绑定开销）、也可能出在 GPU（着色吞吐、带宽、填充、同步）或两者交互（命令缓冲、驱动状态切换）。下文先按流水线顺序把每一步“干了什么”讲透，再总结对症下药的优化策略，并用 OpenGL / Unity / Vulkan / DX12 的代表性代码片段示范“核心做法”。读完你能快速定位瓶颈、选对工具并落地关键代码。

---

## 1 流水线全景

### 1.1 应用层（CPU）

| 任务 | 关键点 |
|----|----|
| 逻辑/动画/物理更新 | **别阻塞渲染线程**：多线程任务系统或 JobSystem，拆分 Transform 更新、剔除、实例数据填充。 |
| 渲染准备 | **填充常量缓冲与命令列表**：DX12 `CommandList`、Vulkan `VkCommandBuffer`，尽量复用、合并，避免 per‑draw 频繁更新常量。 |

> DX12 通过离线录制 `CommandList` + 多线程提交，把原来驱动里不可控的状态切换搬到应用层可控的并行阶段，从根上削减 CPU 开销。citeturn2search0

### 1.2 几何阶段（GPU）

1. **顶点着色** → 2. **图元装配** → 3. **曲面细分/几何着色器(可选)** → 4. **裁剪**。  
Khronos 的官方管线示意是业界共识参考。citeturn1search0

移动 GPU 多为 **Tile‑Based Rendering (TBR)**：把屏幕切成 tile，先在片上内存做深度/颜色，填满再一次性写回帧缓冲，以减少带宽。citeturn2search2

### 1.3 光栅化阶段

- **光栅化**：将三角形转成像素片段；  
- **早深度测试 / Early‑Z**：能丢就丢，减少无用片段成本；  
- **片元/像素着色**：真正跑 BRDF、阴影、后期前的最后一步。  

NVIDIA GPU Gems 的 Occlusion Culling 章节展示了利用 Early‑Z + 硬件查询把不可见物剔掉可省多少片段开销。citeturn0search7

### 1.4 输出合并 & 后期

- **混合/Alpha Blending**：带宽杀手，排序还拖 CPU；  
- **后期链**：Bloom、TAA、Tone‑Mapping……通常占像素着色 30‑60 %。  
在 Vulkan 中把多个后期 passes 打包进同一个 RenderPass，可节约 memory barriers & attachment 复用。citeturn0search5

---

## 2 定位瓶颈的武器

| 工具 | 用途 |
|---|---|
| **Nsight Systems / Nsight Graphics** | CPU–GPU 时间线 + Draw Call 列表，一眼识别“谁等谁”。citeturn0search8 |
| **RenderDoc Pipeline State** | 某一 Draw 的所有绑定、着色器、RT 格式，快速发现多余状态切换或错误压缩格式。citeturn0search9 |
| **Unity Frame Debugger + RenderDoc** | Unity 专案查批处理失败原因、Pass 顺序。 |
| **GPU Counters (PIX/Metal System Trace)** | VS/PS 执行时间、L2 带宽、Early‑Z 命中率。 |

---

## 3 性能优化 12 条硬菜

> **原则：先测量再优化，别把时间花在非瓶颈环节。**

| # | 招式 | 关键点 | 参考 |
|---|---|---|---|
| 1 | **合批/Instancing** | CPU → GPU 调用数是第一瓶颈。OpenGL 一行 `glDrawArraysInstanced` 能把 125 立方体从 125 次 draw → 1 次。示例代码见下。 | citeturn4view0 |
| 2 | **SRP Batcher / Root Signature** | 把材质常量持久 pin 在 GPU，Bind+Draw 串联在一个 ultra‑fast path。Unity 启用 SRP Batcher 可在中大型场景把主线程成本降 30‑60 %。 | citeturn6search0 |
| 3 | **剔除** | 视锥、遮挡、细节剔除 (Hi‑Z)；Unity/UE4 都内置硬件 Occlusion Queries，结合 HZB 可零成本 Early‑Z。 | citeturn1search3turn0search2 |
| 4 | **LOD / HLOD** | UE HLOD 把远处 Actors 合并成代理网格，减少 Draw Call；级距用屏幕像素或体素误差衡量。 | citeturn1search2 |
| 5 | **管线状态合并** | Vulkan 动态状态、DX12 PSO 缓存，避免“PSO 爆炸”。 | citeturn0search5 |
| 6 | **异步计算** | 把后期 AA、粒子 Compute Dispatch 放 Async Queue；但要保证不与光栅化争 bandwidth。 |
| 7 | **材质/Shader Variant 减法** | Keywords=<ũVariant数×SetPassCall数>；剔除死路由或改成 `#pragma multi_compile_local`。 |
| 8 | **带宽杀手管理** | 压缩纹理 (BCn/ASTC)、MSAA 局部解析、半精度 HDR 流程。 |
| 9 | **深度 Pre‑Pass** | 如果片段复杂度高且材质多态，先写深度可让后续 Pass 全跑 Early‑Z。 |
|10 | **Tile/TBR 专属技巧** | 避免不必要的 MRT、保持 tile 只写一次；小视口 UI/效果可用 `glScissor` 减少整屏代价。 |
|11 | **Mip & Streaming** | 保证采样 pixel ≈ 对应 mip，Async Upload 控制峰值显存。 |
|12 | **前沿：Foveated Rendering** | VR 下眼动追踪 + 可变分辨率渲染可让 Quest Pro 场景 fill‑rate 提升 1.4‑1.6×。 | citeturn3search7turn3search9 |

---

## 4 核心代码速查

### 4.1 OpenGL Instancing（几何批渲染）

```cpp
// 普通绘制
glDrawArrays(GL_TRIANGLES, 0, 36);

// 实例化绘制：一次画 125 个立方体
glDrawArraysInstanced(GL_TRIANGLES, 0, 36, 125);
```

在顶点着色器用 `gl_InstanceID` 取偏移表实现“同网格多位置多颜色”：参见完整示例。citeturn4view0

### 4.2 Unity C# GPU Instancing + SRP Batcher

```csharp
var matrices = new Matrix4x4[count];
var props    = new MaterialPropertyBlock();
props.SetVectorArray("_BaseColor", colors);   // 仅 per‑instance 变化的数据

Graphics.DrawMeshInstanced(cubeMesh, 0, instancedMat,
                           matrices, count, props,
                           UnityEngine.Rendering.ShadowCastingMode.On,
                           true, 0, null,
                           UnityEngine.Rendering.LightProbeUsage.Off,
                           null);
```

确保：  
1. Shader 启用 `#pragma multi_compile_instancing`;  
2. 项目设置打开 **SRP Batcher**，同一 Shader Variant 将被一次提交。citeturn6search0

### 4.3 DX12 多线程命令录制

```cpp
// 每帧工作线程
auto list = allocator->GetNewCommandList();
// ... Populate draws
list->Close();
queue->ExecuteCommandLists(1, list.GetAddressOf());
```

主线程仅负责高层调度；Barrier 与 PSO 创建尽量搬到加载期或缓存。citeturn2search0

### 4.4 Vulkan 动态渲染 + 一次 RenderPass 合并后期

```cpp
VkRenderingInfo info{.colorAttachmentCount = 1, ...};
vkCmdBeginRendering(cmd, &info);
// G-Buffer → 直接跑后期 → 输出屏
vkCmdEndRendering(cmd);
```

省去 FB & RP 对象，减少过多 load/store 与 layout 转换。citeturn0search5

---

## 5 落地 Checklist（按优先级）

1. **用工具量化瓶颈**：Nsight/RenderDoc/Frame Debugger。  
2. **Draw Call ≤ 5 k（主机） / ≤ 2 k（移动）**；能 Instancing 就 Instancing。  
3. **每像素执行次数 < 4**：预写深度或利用 Early‑Z。  
4. **每帧带宽 ≤ 显存频宽 × 0.7**：压缩、Tile‑友好渲染。  
5. **材质 + Shader Variant 数量 < 几百**，否则必须剔除/重构。  
6. **后期 Pass 合并 / Async Compute 并行化**。  
7. **开启硬件剔除（Occlusion Query/HZB）与 LOD/HLOD**。  

坚持“测—改—测”闭环：一次改动就复测、对比分帧占比，避免把优化做成玄学。

---

### 小结  
渲染流水线的每一级都有“惯用姿势”和“必踩坑”。**CPU 合批剔除 + GPU 流水线友好 + 带宽友好**是永恒三原则；配合现代 Vulkan/DX12 命令录制、Unity SRP Batcher、UE HLOD 等技术栈，就能把主机大场景压到 16 ms 以内，移动端复杂关卡也能跑稳 60 fps。按本文的流程定位和应用代码模板，可在最短路径上拿到 30 %–5× 不等的性能回报。祝调优顺利！
