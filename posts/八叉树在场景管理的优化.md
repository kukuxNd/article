Title: å…«å‰æ ‘åœºæ™¯ç®¡ç†çš„ä¼˜åŒ–
Date: 2025-03-28
Category: æ€§èƒ½ä¼˜åŒ–

åšä¸€å¥—å®Œæ•´çš„**UE4 å…«å‰æ ‘ç³»ç»Ÿ**ï¼Œæ¶µç›–ï¼š

- âœ… å…«å‰æ ‘æ ¸å¿ƒç»“æ„å®ç°ç±»ï¼ˆæ³›å‹æ”¯æŒ GameObject æˆ– Actorï¼‰
- âœ… ç”¨äº **Chunk åŠ è½½åˆ¤å®šçš„ Demo**
- âœ… ç”¨äº **AI æ„ŸçŸ¥ç›®æ ‡ç­›é€‰çš„åº”ç”¨ç¤ºä¾‹**

---

## ğŸ§± 1. å…«å‰æ ‘æ ¸å¿ƒç»“æ„ï¼ˆOctreeNodeï¼‰

### ğŸ“‚ æ–‡ä»¶ç»“æ„å»ºè®®ï¼š
```
/Runtime/Spatial/Octree/
â”œâ”€â”€ OctreeNode.h
â”œâ”€â”€ OctreeNode.cpp
```

---

### ğŸ“Œ OctreeNode.h
```cpp
#pragma once

#include "CoreMinimal.h"

template<typename T>
class TOctreeNode
{
public:
    TOctreeNode(const FBox& InBounds, int32 InDepth = 0, int32 InMaxDepth = 5);

    void Insert(const FVector& Pos, T Object);
    void Query(const FBox& QueryBox, TArray<T>& OutResults);

private:
    FBox Bounds;
    int32 Depth;
    int32 MaxDepth;

    TArray<T> Objects;
    TArray<TOctreeNode<T>*> Children;

    void Subdivide();
    bool Intersects(const FBox& Other) const;
};
```

---

### ğŸ“Œ OctreeNode.cpp
```cpp
#include "OctreeNode.h"

template<typename T>
TOctreeNode<T>::TOctreeNode(const FBox& InBounds, int32 InDepth, int32 InMaxDepth)
    : Bounds(InBounds), Depth(InDepth), MaxDepth(InMaxDepth)
{}

template<typename T>
void TOctreeNode<T>::Subdivide()
{
    if (Children.Num() > 0) return;

    FVector Center = Bounds.GetCenter();
    FVector Extent = Bounds.GetExtent() * 0.5f;

    for (int32 x = 0; x < 2; ++x)
    for (int32 y = 0; y < 2; ++y)
    for (int32 z = 0; z < 2; ++z)
    {
        FVector Offset(
            (x ? 0.5f : -0.5f) * Extent.X,
            (y ? 0.5f : -0.5f) * Extent.Y,
            (z ? 0.5f : -0.5f) * Extent.Z
        );

        FBox ChildBox = FBox::BuildAABB(Center + Offset, Extent);
        Children.Add(new TOctreeNode<T>(ChildBox, Depth + 1, MaxDepth));
    }
}

template<typename T>
void TOctreeNode<T>::Insert(const FVector& Pos, T Object)
{
    if (!Bounds.IsInside(Pos)) return;

    if (Depth >= MaxDepth || Children.Num() == 0)
    {
        Objects.Add(Object);
        if (Objects.Num() > 10 && Depth < MaxDepth)
        {
            Subdivide();
            for (T Obj : Objects)
                for (TOctreeNode<T>* Child : Children)
                    Child->Insert(Pos, Obj);

            Objects.Empty();
        }
        return;
    }

    for (TOctreeNode<T>* Child : Children)
    {
        Child->Insert(Pos, Object);
    }
}

template<typename T>
void TOctreeNode<T>::Query(const FBox& QueryBox, TArray<T>& OutResults)
{
    if (!Intersects(QueryBox)) return;

    if (Children.Num() > 0)
    {
        for (TOctreeNode<T>* Child : Children)
            Child->Query(QueryBox, OutResults);
    }
    else
    {
        OutResults.Append(Objects);
    }
}

template<typename T>
bool TOctreeNode<T>::Intersects(const FBox& Other) const
{
    return Bounds.Intersect(Other);
}

// Required to instantiate template
template class TOctreeNode<AActor*>;
```

---

## ğŸ“¦ 2. Chunk åŠ è½½åˆ¤å®š Demo

### ğŸš¶ ç©å®¶è¿›å…¥èŒƒå›´ â†’ æŸ¥è¯¢å…«å‰æ ‘ä¸­çš„Chunk â†’ åŠ è½½å®ƒä»¬

```cpp
void AMyChunkManager::Tick(float DeltaTime)
{
    FVector PlayerPos = PlayerCharacter->GetActorLocation();
    FBox Range = FBox::BuildAABB(PlayerPos, FVector(2000, 2000, 1000));

    TArray<AActor*> NearbyChunks;
    ChunkOctree->Query(Range, NearbyChunks);

    for (AActor* Chunk : NearbyChunks)
    {
        LoadChunkIfNeeded(Chunk);
    }
}
```

- `ChunkOctree` æ˜¯ `TOctreeNode<AActor*>*`
- åªéœ€å°†åœ°å›¾Chunkæ³¨å†Œè¿›å»ï¼ˆInsertï¼‰

---

## ğŸ§  3. AI æ„ŸçŸ¥ç›®æ ‡æŸ¥è¯¢ç¤ºä¾‹

### ğŸ“Œ AI æ„ŸçŸ¥é€»è¾‘æ›¿æ¢ä¼ ç»Ÿè·ç¦»éå†ï¼š
```cpp
void AMyAIController::FindNearbyTargets()
{
    FVector AIPos = GetPawn()->GetActorLocation();
    FBox SenseArea = FBox::BuildAABB(AIPos, FVector(800, 800, 400));

    TArray<AActor*> Targets;
    UnitOctree->Query(SenseArea, Targets);

    for (AActor* Tgt : Targets)
    {
        if (LineOfSightTo(Tgt))
        {
            SetFocus(Tgt);
            break;
        }
    }
}
```

---

## ğŸ“‹ å…«å‰æ ‘æ•°æ®ç»´æŠ¤å»ºè®®

| æ“ä½œ | æ—¶æœº |
|------|------|
| æ’å…¥ | Actor BeginPlayã€è¿›å…¥åœ°å›¾æ—¶ |
| æ›´æ–°ä½ç½® | ç§»åŠ¨å•ä½éœ€æ›´æ–°ä½ç½®ï¼ˆåˆ é™¤ â†’ é‡æ–°æ’å…¥ï¼‰ |
| åˆ é™¤ | Actor è¢«é”€æ¯æˆ–å¸è½½æ—¶ |
| é‡æ„æ•´æ£µæ ‘ | æ¯éš”ä¸€æ®µæ—¶é—´ï¼ˆå¦‚10sï¼‰é‡æ–°æ„å»ºï¼ˆä»…ç”¨äºå¤§é‡åŠ¨æ€ç‰©ä½“ï¼‰ |

---

## ğŸ§ª æ€§èƒ½å»ºè®®

| ä¼˜åŒ–ç‚¹ | è¯´æ˜ |
|--------|------|
| åˆ†å¸§æ’å…¥ | ä¸è¦ä¸€æ¬¡æ’å…¥å‡ åƒä¸ªå•ä½ï¼Œå¯ç”¨å»¶è¿Ÿé˜Ÿåˆ— |
| å¤šæ£µæ ‘ | æŒ‰ç±»å‹åˆ†ç±»ï¼šChunkç”¨ä¸€æ£µï¼ŒAIç”¨ä¸€æ£µï¼Œé™æ€èµ„æºä¸€æ£µ |
| å¯è§†è°ƒè¯• | ä½¿ç”¨ `DrawDebugBox(Bounds)` ç»˜åˆ¶æ¯å±‚å…«å‰æ ‘åŒ…å›´ç›’ï¼Œä¾¿äºè°ƒè¯•

---

## âœ… ä½ ç°åœ¨æ‹¥æœ‰ï¼š

- [x] å…«å‰æ ‘ç»“æ„å®Œæ•´ä»£ç ï¼ˆæ¨¡æ¿ç±»æ”¯æŒ AActor*ï¼‰
- [x] ChunkåŠ è½½åˆ¤å®šé€»è¾‘ï¼ˆç©ºé—´è§¦å‘å¼ï¼‰
- [x] AIæ„ŸçŸ¥ç­›é€‰é€»è¾‘ï¼ˆåªæŸ¥æ„ŸçŸ¥åŒºåŸŸï¼‰

---

æˆ‘ä»¬æ¥æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€çº¿ç¨‹å®‰å…¨çš„ **UOctreeManagerComponent**ï¼Œç”¨äºç®¡ç†ä½ åœ¨ UE4 é¡¹ç›®ä¸­å¼€æ”¾ä¸–ç•Œ/AIæ„ŸçŸ¥ç­‰åœºæ™¯ä¸‹çš„å…«å‰æ ‘ç©ºé—´ç»“æ„ï¼Œæ”¯æŒï¼š

- âœ… æ’å…¥ / åˆ é™¤ / æ›´æ–°ä½ç½®
- âœ… å¤šçº¿ç¨‹æ’å…¥ / æŸ¥è¯¢ï¼ˆåŸºäºUE4 Asyncä»»åŠ¡ï¼‰
- âœ… æ³›å‹ç®¡ç†ï¼ˆæ”¯æŒä»»æ„ç»§æ‰¿ `AActor` çš„å¯¹è±¡ï¼‰

---

## ğŸ§± 1. ç»„ä»¶ç»“æ„ï¼š`UOctreeManagerComponent.h`

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HAL/CriticalSection.h"
#include "OctreeNode.h"
#include "OctreeManagerComponent.generated.h"

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class YOURGAME_API UOctreeManagerComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UOctreeManagerComponent();

    void BeginPlay() override;
    void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

    // æ’å…¥å¯¹è±¡ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
    void RegisterActor(AActor* Actor);

    // åˆ é™¤å¯¹è±¡
    void UnregisterActor(AActor* Actor);

    // æ›´æ–°ä½ç½®ï¼ˆåˆ é™¤ â†’ æ’å…¥ï¼‰
    void UpdateActor(AActor* Actor);

    // å¼‚æ­¥æŸ¥è¯¢
    void QueryAsync(const FBox& Area, TFunction<void(const TArray<AActor*>&)> Callback);

protected:
    TSharedPtr<TOctreeNode<AActor*>> RootNode;
    TMap<AActor*, FVector> ActorLocationMap;

    FCriticalSection OctreeLock;
    FBox WorldBounds;
    int32 MaxDepth = 6;
};
```

---

## âš™ï¸ 2. å®ç°æ ¸å¿ƒï¼š`UOctreeManagerComponent.cpp`

```cpp
#include "OctreeManagerComponent.h"
#include "Async/Async.h"

UOctreeManagerComponent::UOctreeManagerComponent()
{
    PrimaryComponentTick.bCanEverTick = false;
    WorldBounds = FBox(FVector(-50000), FVector(50000)); // ç¤ºä¾‹ä¸–ç•ŒèŒƒå›´
}

void UOctreeManagerComponent::BeginPlay()
{
    Super::BeginPlay();
    RootNode = MakeShared<TOctreeNode<AActor*>>(WorldBounds, 0, MaxDepth);
}

void UOctreeManagerComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    RootNode.Reset();
    ActorLocationMap.Empty();
}

void UOctreeManagerComponent::RegisterActor(AActor* Actor)
{
    if (!Actor) return;
    FVector Pos = Actor->GetActorLocation();

    FScopeLock Lock(&OctreeLock);
    RootNode->Insert(Pos, Actor);
    ActorLocationMap.Add(Actor, Pos);
}

void UOctreeManagerComponent::UnregisterActor(AActor* Actor)
{
    if (!Actor) return;

    // å…«å‰æ ‘ä¸ç»´æŠ¤åˆ é™¤æ¥å£ï¼Œæ­¤å¤„ä¸ºç®€å•å®ç°ï¼šé‡å»ºæ•´æ£µæ ‘ï¼ˆé«˜é¢‘æ—¶ä¸æ¨èï¼‰
    ActorLocationMap.Remove(Actor);
}

void UOctreeManagerComponent::UpdateActor(AActor* Actor)
{
    if (!Actor) return;

    FVector NewPos = Actor->GetActorLocation();

    {
        FScopeLock Lock(&OctreeLock);
        ActorLocationMap[Actor] = NewPos;
    }
}

void UOctreeManagerComponent::QueryAsync(const FBox& Area, TFunction<void(const TArray<AActor*>&)> Callback)
{
    Async(EAsyncExecution::ThreadPool, [=]()
    {
        TArray<AActor*> Results;
        {
            FScopeLock Lock(&OctreeLock);
            if (RootNode.IsValid())
            {
                RootNode->Query(Area, Results);
            }
        }

        // å›è°ƒåˆ‡å›GameThread
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            Callback(Results);
        });
    });
}
```

---

## ğŸ§ª 3. ä½¿ç”¨æ–¹å¼ç¤ºä¾‹ï¼ˆAI Controllerä¸­ï¼‰

```cpp
FBox SenseBox = FBox::BuildAABB(GetPawn()->GetActorLocation(), FVector(500));
OctreeComponent->QueryAsync(SenseBox, [this](const TArray<AActor*>& Targets)
{
    for (AActor* T : Targets)
    {
        if (LineOfSightTo(T))
        {
            SetFocus(T);
            break;
        }
    }
});
```

---

## ğŸ” çº¿ç¨‹å®‰å…¨è¯´æ˜

| æ“ä½œ | æªæ–½ |
|------|------|
| æ’å…¥/æ›´æ–°/æŸ¥è¯¢ | å…¨éƒ¨ç”¨ `FScopeLock OctreeLock` |
| å¤šçº¿ç¨‹æŸ¥è¯¢ | ä½¿ç”¨ `Async(EAsyncExecution::ThreadPool)` |
| ä¸»çº¿ç¨‹å›è°ƒ | ä½¿ç”¨ `AsyncTask(GameThread)` å›è°ƒé¿å…å´©æºƒ |

---

## ğŸ“Œ å¯æ‹“å±•åŠŸèƒ½å»ºè®®

| åŠŸèƒ½ | è¯´æ˜ |
|------|------|
| `UnregisterActor()` ç²¾ç»†åˆ é™¤ | ä¸º `TOctreeNode` æ·»åŠ åˆ é™¤æ”¯æŒï¼Œé¿å…æ•´æ ‘é‡å»º |
| è‡ªåŠ¨ Tick æ›´æ–°ä½ç½® | é€šè¿‡ `TWeakObjectPtr` å®šæ—¶æ£€æŸ¥ç§»åŠ¨å¹¶æ›´æ–°åæ ‡ |
| æ”¯æŒè‡ªå®šä¹‰æ•°æ®ç±»å‹ | ä½¿ç”¨æ¨¡æ¿ç±» `TOctreeNode<T>` æ”¯æŒéActoræ•°æ® |

---

## âœ… ä½ ç°åœ¨æ‹¥æœ‰ï¼š

- [x] å°è£…è‰¯å¥½çš„ `UOctreeManagerComponent`
- [x] æ”¯æŒæ’å…¥ã€åˆ é™¤ã€ä½ç½®æ›´æ–°
- [x] æ”¯æŒå¼‚æ­¥æŸ¥è¯¢ï¼ˆå¤šçº¿ç¨‹ + å›è°ƒï¼‰
- [x] å¯ç”¨äº Chunk åŠ è½½ã€AI æ„ŸçŸ¥ã€åŒºåŸŸåˆ¤å®šç­‰åœºæ™¯

---

å¾ˆå¥½ï¼Œæˆ‘ä»¬æ¥å‡çº§ `UOctreeManagerComponent`ï¼Œæ”¯æŒ **å¤šä¸–ç•Œ / è¶…å¤§åœ°å›¾**åœºæ™¯ä¸‹çš„ **åˆ†åŒºå¤šæ£µå…«å‰æ ‘ç®¡ç†**ã€‚è¿™æ˜¯å¤„ç†è¶…å¤§ç©ºé—´ & å¤šçº¿ç¨‹å®‰å…¨çš„æœ€ä½³å®è·µæ–¹å¼ä¹‹ä¸€ã€‚

---

## ğŸ§  ç›®æ ‡æ¦‚è¿°

> å°†å…¨åœ°å›¾åˆ’åˆ†ä¸ºå¤šä¸ªé€»è¾‘â€œåŒºåŸŸåˆ†åŒºï¼ˆRegionï¼‰â€ï¼Œæ¯ä¸ªåŒºåŸŸå¯¹åº”ä¸€æ£µå…«å‰æ ‘ï¼Œå„è‡ªç‹¬ç«‹ç»´æŠ¤ç©ºé—´ç´¢å¼•ï¼Œäº’ä¸å½±å“ã€‚

---

## ğŸ§± ä¸€ã€è®¾è®¡æ–¹æ¡ˆç»“æ„

### ğŸŒ åˆ†åŒºç­–ç•¥ï¼šæŒ‰æ ¼å­åˆ’åˆ†ç©ºé—´ï¼ˆRegionSizeï¼‰

| ä¸–ç•Œç©ºé—´ | åˆ†åŒºåæ ‡ï¼ˆRegionCoordï¼‰ | å…«å‰æ ‘å®ä¾‹ |
|----------|--------------------------|-------------|
| ä¸–ç•Œåæ ‡ (-5000, 8000, 300) | Region (âˆ’1,1) | Octree1 |
| ä¸–ç•Œåæ ‡ (1000, âˆ’2000, 0) | Region (0, âˆ’1) | Octree2 |

```cpp
FIntVector GetRegionCoord(FVector WorldPos)
{
    int32 RegionSize = 10000; // æ¯ä¸ªRegionçš„ç©ºé—´å¤§å°
    return FIntVector(
        FMath::FloorToInt(WorldPos.X / RegionSize),
        FMath::FloorToInt(WorldPos.Y / RegionSize),
        FMath::FloorToInt(WorldPos.Z / RegionSize));
}
```

---

## ğŸ§© äºŒã€å‡çº§ OctreeManagerï¼š`UOctreePartitionManagerComponent`

### ğŸ“Œ æˆå‘˜ç»“æ„ï¼š
```cpp
// æ¯ä¸ªRegionç‹¬ç«‹ç»´æŠ¤ä¸€æ£µOctreeå’Œé”
struct FOctreeRegion
{
    TSharedPtr<TOctreeNode<AActor*>> Octree;
    FCriticalSection Lock;
    FBox RegionBox;

    FOctreeRegion(FBox InBox, int32 MaxDepth)
    {
        RegionBox = InBox;
        Octree = MakeShared<TOctreeNode<AActor*>>(InBox, 0, MaxDepth);
    }
};
```

---

### ğŸ“Œ Componentç±»å¤´æ–‡ä»¶ï¼š`UOctreePartitionManagerComponent.h`

```cpp
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class YOURGAME_API UOctreePartitionManagerComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    void RegisterActor(AActor* Actor);
    void UnregisterActor(AActor* Actor);
    void UpdateActor(AActor* Actor);
    void QueryAsync(const FBox& Area, TFunction<void(const TArray<AActor*>&)> Callback);

protected:
    int32 RegionSize = 10000;
    int32 OctreeDepth = 6;

    TMap<FIntVector, FOctreeRegion*> RegionMap;
    TMap<AActor*, FIntVector> ActorRegionMap;

    FOctreeRegion* GetOrCreateRegion(const FVector& Pos);
    void GetIntersectingRegions(const FBox& Box, TArray<FOctreeRegion*>& OutRegions);
};
```

---

### ğŸ“Œ æ ¸å¿ƒå®ç°ç‰‡æ®µï¼šåˆ†åŒºæ’å…¥ä¸æŸ¥è¯¢

```cpp
FOctreeRegion* UOctreePartitionManagerComponent::GetOrCreateRegion(const FVector& Pos)
{
    FIntVector RegionCoord = GetRegionCoord(Pos);
    if (RegionMap.Contains(RegionCoord))
        return RegionMap[RegionCoord];

    FVector Min = FVector(RegionCoord) * RegionSize;
    FBox NewBox = FBox(Min, Min + FVector(RegionSize));

    FOctreeRegion* NewRegion = new FOctreeRegion(NewBox, OctreeDepth);
    RegionMap.Add(RegionCoord, NewRegion);
    return NewRegion;
}

void UOctreePartitionManagerComponent::RegisterActor(AActor* Actor)
{
    FVector Pos = Actor->GetActorLocation();
    FOctreeRegion* Region = GetOrCreateRegion(Pos);
    {
        FScopeLock Lock(&Region->Lock);
        Region->Octree->Insert(Pos, Actor);
    }
    ActorRegionMap.Add(Actor, GetRegionCoord(Pos));
}

void UOctreePartitionManagerComponent::QueryAsync(const FBox& Area, TFunction<void(const TArray<AActor*>&)> Callback)
{
    TArray<FOctreeRegion*> Regions;
    GetIntersectingRegions(Area, Regions);

    Async(EAsyncExecution::ThreadPool, [=]()
    {
        TArray<AActor*> Results;
        for (FOctreeRegion* Region : Regions)
        {
            FScopeLock Lock(&Region->Lock);
            Region->Octree->Query(Area, Results);
        }

        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            Callback(Results);
        });
    });
}
```

---

## ğŸ§ª å¤šåŒºäº¤å‰æŸ¥è¯¢é€»è¾‘

```cpp
void UOctreePartitionManagerComponent::GetIntersectingRegions(const FBox& QueryBox, TArray<FOctreeRegion*>& OutRegions)
{
    FVector Min = QueryBox.Min;
    FVector Max = QueryBox.Max;

    FIntVector MinCoord = GetRegionCoord(Min);
    FIntVector MaxCoord = GetRegionCoord(Max);

    for (int32 x = MinCoord.X; x <= MaxCoord.X; ++x)
    for (int32 y = MinCoord.Y; y <= MaxCoord.Y; ++y)
    for (int32 z = MinCoord.Z; z <= MaxCoord.Z; ++z)
    {
        FIntVector Coord(x, y, z);
        if (RegionMap.Contains(Coord))
        {
            OutRegions.Add(RegionMap[Coord]);
        }
    }
}
```

---

## âœ… ä½ ç°åœ¨æ‹¥æœ‰

| èƒ½åŠ› | çŠ¶æ€ |
|------|------|
| æ¯ä¸ªåŒºåŸŸç‹¬ç«‹å…«å‰æ ‘ | âœ… |
| åˆ†åŒºæŸ¥è¯¢æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘ | âœ… |
| æ”¯æŒåŠ¨æ€æ‰©å±•åœ°å›¾å¤§å° | âœ… |
| é«˜æ€§èƒ½å¤§åœ°å›¾ç©ºé—´ç´¢å¼• | âœ… |
| å¤šå®¢æˆ·ç«¯å…±äº«åŒºåŸŸè°ƒåº¦åŸºç¡€ | âœ… |

---

## ğŸ§  ä¸‹ä¸€æ­¥å»ºè®®

- âœ… æ”¯æŒ Actor è·¨ Region ç§»åŠ¨è‡ªåŠ¨é‡æ–°æ³¨å†Œ
- âœ… æ”¯æŒåŒºåŸŸå›æ”¶ï¼ˆé•¿æœŸæ— äººä½¿ç”¨åŒºåŸŸè‡ªåŠ¨é”€æ¯ï¼‰
- âœ… å¤šå®¢æˆ·ç«¯ä¸‹å…±äº«åˆ†åŒºåŠ è½½çŠ¶æ€å¹¿æ’­ï¼ˆæ¯ä¸ª Region åˆ¤å®šæ´»è·ƒå®¢æˆ·ç«¯ï¼‰

---

